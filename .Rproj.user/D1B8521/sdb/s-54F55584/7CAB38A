{
    "contents" : "HTMLWidgets.widget({\n\n  name: 'clusterpie4widget',\n\n  type: 'output',\n\n  initialize: function(el,width, height) {\n    var mapdiv = document.createElement(\"div\");\n    mapdiv.id = \"map\";\n    el.appendChild(mapdiv);\n\n    return {\n      // TODO: add instance fields as required\n    };\n\n  },\n\n  renderValue: function(el, x,  instance) {\n\n\n \"use strict\";\n//    iconField = '5065', //This is the fieldame for marker icon\n  var geojson,\n    metadata,\n    geojsonPath,\n    categoryField = 'allele', //This is the fieldname for marker category (used in the pie and legend)\n    popupFields = ['popname', 'sampid','allele'], //Popup will display these fields\n    tileServer = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n    tileAttribution =  'Map data: <a href=\"http://openstreetmap.org\">OSM</a>',\n    rmax = 32, //Maximum radius for cluster pies\n    markerclusters = L.markerClusterGroup({\n      maxClusterRadius: 1.75*rmax,\n      iconCreateFunction: defineClusterIcon, //this is where the magic happens\n    showCoverageOnHover: false,\n\t\tzoomToBoundsOnClick: true\n    }),\n    map = L.map('map').setView([40, 120], 2);\n\n  //Add basemap\n // L.tileLayer(tileServer, {attribution: tileAttribution,  maxZoom: 15, minZoom: 2}).addTo(map);\n  L.tileLayer('http://mt{s}.google.com/vt/v=w2.106&x={x}&y={y}&z={z}&s=', {subdomains:'0123',attribution:'&copy;Google2012',maxZoom: 10, minZoom: 2}).addTo(map);\n // L.tileLayer('http://c.tiles.mapbox.com/v3/examples.map-szwdot65/{Z}/{X}/{Y}.png').addTo(map);\n\n\n  //and the empty markercluster layer\n  map.addLayer(markerclusters);\n\n  //Ready to go, load the geojson\n\n  if (x.server != null) {\n    geojsonPath = 'http://' + x.server + '/' + x.geojsonfile;\n\n  d3.json(geojsonPath, function(error, data) {\n      if (!error){\n          geojson = data;\n          metadata = data.properties;\n          var markers = L.geoJson(geojson, {\n  \t\tpointToLayer: defineFeature,\n\t\t\tonEachFeature: defineFeaturePopup\n          });\n          markerclusters.addLayer(markers);\n          map.fitBounds(markers.getBounds());\n          map.attributionControl.addAttribution(metadata.attribution);\n          renderLegend();\n      } else {\n\t  console.log('Could not load data...');\n      }\n  });\n} else {\nvar data = JSON.parse(x.data);\ngeojson = data;\n\nmetadata = data.properties;\nvar markers = L.geoJson(geojson, {\n    pointToLayer: defineFeature,\n\t\tonEachFeature: defineFeaturePopup\n    });\nmarkerclusters.addLayer(markers);\nmap.fitBounds(markers.getBounds());\nmap.attributionControl.addAttribution(metadata.attribution);\nrenderLegend();\n}\n\nfunction defineFeature(feature, latlng) {\n  \tvar categoryVal = feature.properties[categoryField],\n     \tname = feature.properties['name'];\n\n    //iconVal = feature.properties[iconField];\n    var myClass = 'marker icon-'+metadata.fields[categoryField].lookup[categoryVal]+' allele-'+metadata.fields[categoryField].lookup[categoryVal];\n    var myIcon = L.divIcon({\n        className: myClass,\n        iconSize:null\n    });\n    return L.marker(latlng, {icon: myIcon});\n}\n\nfunction defineFeaturePopup(feature, layer) {\n  var props = feature.properties,\n    fields = metadata.fields,\n    popupContent = '';\n\n  popupFields.map( function(key) {\n    if (props[key]) {\n      var val = props[key],\n        label = fields[key].name;\n      if (fields[key].lookup) {\n        val = fields[key].lookup[val];\n      }\n      popupContent += '<span class=\"attribute\"><span class=\"label\">'+label+':</span> '+val+'</span>';\n    }\n  });\n  popupContent = '<div class=\"map-popup\">'+popupContent+'</div>';\n  layer.bindPopup(popupContent,{offset: L.point(1,-2)});\n}\n\nfunction defineClusterIcon(cluster) {\n\n    var children = cluster.getAllChildMarkers(),\n        n = children.length, //Get number of markers in cluster\n        strokeWidth = 1, //Set clusterpie stroke width\n        r = rmax-2*strokeWidth-(n<10?12:n<100?8:n<1000?4:0), //Calculate clusterpie radius...\n        iconDim = (r+strokeWidth)*2, //...and divIcon dimensions (leaflet really want to know the size)\n        data = d3.nest() //Build a dataset for the pie chart\n          .key(function(d) { return d.feature.properties[categoryField]; })\n          .entries(children, d3.map),\n        //bake some svg markup\n        html = bakeThePie({data: data,\n                            valueFunc: function(d){return d.values.length;},\n                            strokeWidth: 1,\n                            outerRadius: r,\n                            innerRadius: r-10,\n                            pieClass: 'cluster-pie',\n                            pieLabel: n,\n                            pieLabelClass: 'marker-cluster-pie-label',\n                            pathClassFunc: function(d){return \"allele-\"+metadata.fields[categoryField].lookup[d.data.key];},\n                            pathTitleFunc: function(d){\n                              var poplist = d3.nest()\n          .key(function(d) { return d.feature.properties[\"popname\"];})\n          .entries(d.data.values);\n                              var pops = \"\";\n                              for (var k = 0; k < poplist.length; ++k) {\n                                var p = poplist[k];\n                                pops = pops + p[\"key\"] + \"\\n\";\n                              }\n                              return   pops + \"\\n\" + metadata.fields[categoryField].lookup[d.data.key]+' ('+d.data.values.length+' chrom'+(d.data.values.length!=1?'s':'')+')';}\n                          }),\n        //Create a new divIcon and assign the svg markup to the html property\n        myIcon = new L.DivIcon({\n            html: html,\n            className: 'marker-cluster',\n            iconSize: new L.Point(iconDim, iconDim)\n        });\n\n\n\n        for (var item in data.data) {\n        console.log(item+\":\"+data.data[item]);\n        }\n    return myIcon;\n}\n\n/*function that generates a svg markup for the pie chart*/\nfunction bakeThePie(options) {\n    /*data and valueFunc are required*/\n    if (!options.data || !options.valueFunc) {\n        return '';\n    }\n        // rInner = options.innerRadius?options.innerRadius:r-10, //Default inner radius = r-10\n  var data = options.data,\n        valueFunc = options.valueFunc,\n        r = options.outerRadius?options.outerRadius:28, //Default outer radius = 28px\n\t\trInner=0,\n       strokeWidth = options.strokeWidth?options.strokeWidth:1, //Default stroke is 1\n        pathClassFunc = options.pathClassFunc?options.pathClassFunc:function(){return '';}, //Class for each path\n        pathTitleFunc = options.pathTitleFunc?options.pathTitleFunc:function(){return '';}, //Title for each path\n        pieClass = options.pieClass?options.pieClass:'marker-cluster-pie', //Class for the whole pie\n        pieLabel = options.pieLabel?options.pieLabel:d3.sum(data,valueFunc), //Label for the whole pie\n        pieLabelClass = options.pieLabelClass?options.pieLabelClass:'marker-cluster-pie-label',//Class for the pie label\n\n\n        origo = (r+strokeWidth), //Center coordinate\n        w = origo*2, //width and height of the svg element\n        h = w,\n        donut = d3.layout.pie(),\n        arc = d3.svg.arc().innerRadius(rInner).outerRadius(r);\n\n    //Create an svg element\n    var svg = document.createElementNS(d3.ns.prefix.svg, 'svg');\n    //Create the pie chart\n    var vis = d3.select(svg)\n        .data([data])\n        .attr('class', pieClass)\n        .attr('width', w)\n        .attr('height', h);\n\n    var arcs = vis.selectAll('g.arc')\n        .data(donut.value(valueFunc))\n        .enter().append('svg:g')\n        .attr('class', 'arc')\n        .attr('transform', 'translate(' + origo + ',' + origo + ')');\n\n    arcs.append('svg:path')\n        .attr('class', pathClassFunc)\n        .attr('stroke-width', strokeWidth)\n        .attr('d', arc)\n        .append('svg:title')\n          .text(pathTitleFunc);\n\n    vis.append('text')\n        .attr('x',origo)\n        .attr('y',origo)\n        .attr('class', pieLabelClass)\n        .attr('text-anchor', 'middle')\n        //.attr('dominant-baseline', 'central')\n        //*IE doesnt seem to support dominant-baseline, but setting dy to .3em does the trick*/\n        .attr('dy','.3em')\n        .text(pieLabel);\n    //Return the svg-markup rather than the actual element\n    return serializeXmlNode(svg);\n}\n\n/*Function for generating a legend with the same categories as in the clusterPie*/\nfunction renderLegend() {\n    var data = d3.entries(metadata.fields[categoryField].lookup),\n      legenddiv = d3.select('body').append('div')\n        .attr('id','legend');\n\n    var heading = legenddiv.append('div')\n        .classed('legendheading', true)\n        .text(metadata.fields['description']);\n\n    var legenditems = legenddiv.selectAll('.legenditem')\n        .data(data);\n\n    legenditems\n        .enter()\n        .append('div')\n        .attr('class',function(d){return 'allele-'+d.value;})\n        .classed({'legenditem': true})\n        .text(function(d){return (d.value+\": \"+d.key);});\n}\n\n/*Helper function*/\nfunction serializeXmlNode(xmlNode) {\n    if (typeof window.XMLSerializer != \"undefined\") {\n        return (new window.XMLSerializer()).serializeToString(xmlNode);\n    } else if (typeof xmlNode.xml != \"undefined\") {\n        return xmlNode.xml;\n    }\n    return \"\";\n}\n\n\n  },\n\n  resize: function(el, width, height, instance) {\n\n  }\n\n});\n",
    "created" : 1444940085819.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3225760739",
    "id" : "7CAB38A",
    "lastKnownWriteTime" : 1445445074,
    "path" : "C:/Users/dwitonsk/Dropbox/DataViz/RGGV/inst/htmlwidgets/clusterpie4widget.js",
    "project_path" : "inst/htmlwidgets/clusterpie4widget.js",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "js"
}