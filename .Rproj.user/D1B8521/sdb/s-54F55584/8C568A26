{
    "contents" : "\n\n#' Map variant in GGV\n#'\n#' @description\n#' \\code{ggv} takes either a string \\code{rs} or a numeric physical position specified by\n#' arguments \\code{chr} and \\code{pos}. If neither identifier is specified, a random variant\n#' is mapped. Variants from either the HGDP or 1000 genomes can be retrieved by setting\n#' \\code{db = \"hgdp\"} (default) or \\code{db = \"1kgenomes\"}.\n#'\n#' @details\n#' Creates a cluster pie map from variant data in the GGV. Variants can be\n#' retrieved by rs ID or physical position. If neither rs ID or physical\n#' position is specified, a random SNP will be retrieved. The variant data\n#' can be accessed from either the HGDP or 1kgenome databases. To produce a table\n#' instead of a map, set \\code{table = TRUE}.\n#'\n#' @param rs A SNP ID (string)\n#' @param chr Chromosome (numeric)\n#' @param pos Physical position (numeric)\n#' @param db Database \"hgdp\" (default) or \"1kgenomes\"\n#' @param table (boolean)\n#' @examples\n#' ggv(\"rs1834640\")\n#' ggv()\n#' ggv(, 6, 130099903, db = \"1kgenomes\")\n#' @export ggv\nggv <- function(rs = NULL, chr = NULL, pos = NULL, db = \"hgdp\", table=FALSE) {\n  if (db == \"1kgenomes\" || db == \"1000genomes\")\n    db = \"1000genomes_phase3\"\n  api = 'http://popgen.uchicago.edu/ggv_api/freq_table?data=\"'\n  if (!is.null(rs)) {\n    api <- paste0(api, db, '_table\\\"&rsID=', rs)\n  }\n  else if (!is.null(chr) && !is.null(pos)) {\n    api = paste0(api, db, '_table\\\"&chr=', chr, \"&pos=\", pos)\n    rs <- paste0(\"chr\",as.character(chr),\":\",as.character(pos))\n  }\n  else {\n    message(paste0(\"searching for random SNP in \", db))\n    api = paste0(api, db, '_table\"&random_snp=True')\n  }\n\n  ggvjson <- try(RJSONIO::fromJSON(api), silent=TRUE)\n  if (inherits(ggvjson, \"try-error\")) {\n    p = testggv()\n    if (p == 0)\n      message(paste0(\"Variant \", rs, \" not found in \", toupper(db)))\n  }\n  else if (table) {\n    tab <- json2table(ggvjson, rs, db)\n    return(tab)\n  }\n  else {\n    geojson <- json2geojson(ggvjson, rs, db)\n    if (!is.null(geojson))\n      clusterpie(geojson)\n  }\n}\n\n#' @export testSNPs\ntestSNPs <- function() {\n  s <- select.list(c(\"rs1426654\",\"rs1834640\"))\n  if (s == \"rs1426654\")\n    ggv(\"rs1426654\", db=\"1kgenomes\")\n  else if (s == \"rs1834640\")\n    ggv(\"rs1834640\")\n}\n\n\njson2table <- function(json, rs, db) {\n   freqtable <- NULL\n  for (i in 1:length(json)) {\n    freq <- as.numeric(json[[i]]$freq)\n    pop <- json[[i]]$pop\n    coord <- as.numeric(json[[i]]$pos)\n    freqtable <- rbind(freqtable, list(pop, coord[2], coord[1], round(freq[1],2)))\n  }\n  freqtable <- data.frame(freqtable)\n  colnames(freqtable) <- c(\"Pop\", \"lat\", \"long\" , \"freq\")\n  return(freqtable)\n}\n\n\n\njson2geojson <- function(json, rs, db) {\n  geom <- NULL\n  pos <- json[[1]]$chrom_pos\n  alleles <- json[[1]]$alleles\n  #  alleles = c(\"A\", \"G\")\n  splpos <- unlist(strsplit(pos,\":\"))\n  ancstate <- ancestralState(splpos[1], as.numeric(splpos[2]), db)\n  message(paste0(\"SNP pos: chr\", splpos[1], \":\", splpos[2]))\n  message(paste0(\"Ancestral state: \", ancstate))\n  for (i in 1:length(json)) {\n    nobs <- as.numeric(json[[i]]$nobs)\n    xobs <- as.numeric(json[[i]]$xobs)\n    pop <- json[[i]]$pop\n    coord <- as.numeric(json[[i]]$pos)\n\n    #print(coord)\n    for (j in 1:nobs) {\n      al <- alleles[2]\n      if (xobs > 0){\n        al <- alleles[1]\n        xobs <- xobs - 1\n      }\n      g <- list(geometry=list(type=\"Point\",coordinates=coord), type=\"Feature\", properties=c(popname=pop,allele=al))\n      geom[[length(geom)+1]] <- g\n    }\n  }\n\n  ancder <- c(\"Ancestral\", \"Derived\")\n  if (ancstate == alleles[2])\n    ancder <- rev(ancder)\n  else if (ancstate != alleles[1] && ancstate != alleles[2])\n    ancder <- c(\"State1\", \"State2\")\n  names(ancder) <- alleles\n  pname <- c(name=toupper(db))\n  if (is.null(rs)) rs <- pos\n  geojson <- list(type=\"FeatureCollection\", features=geom,\n                  properties=list(fields=list(allele=list(lookup=ancder, name=\"Ancestral State\"),\n                                              popname=pname, attribution=\"XXXXX\", description=rs)))\n  #writeLines(toJSON(geojson), \"jnk.geojson\")\n  return(RJSONIO::toJSON(geojson))\n\n}\n\nparseSNPID <- function(snpid) {\n  snp <- getSNP(snpid)\n  pos <- as.numeric(snp[\"chrom_start\"])\n  chr <- as.character(snp[\"chr_name\"])\n  alleles <- unlist(strsplit(as.character(snp[\"allele\"]), \"/\"))\n  #anc <- as.character(snp[\"allele_1\"])\n  anc <- ancestralState(chr, pos, db)\n  anc.der <- alleles[which(alleles == anc):which(alleles != anc)]\n  names(anc.der) <- c(\"anc\", \"der\")\n  message(paste0(\"snp ID: \", snpid))\n  message(paste0(\"pos B37: \", chr, \":\", pos))\n  message(paste0(\"ancestral: \", anc.der[\"anc\"], \" derived: \", anc.der[\"der\"]))\n  snpinfo <- list(\"snpid\" = snpid, \"chr\" = chr, \"pos\" = pos, \"anc.der\" = anc.der)\n  return(snpinfo)\n}\n\ngetSNP <- function(the.snp = \"rs12913832\", chr=NULL, pos = NULL, build = \"B37\") {\n  message(paste0(\"looking up SNP \", the.snp, \" in build \", build))\n  snp.db <- biomaRt::useEnsembl(biomart = \"snp\", dataset = \"hsapiens_snp\", GRCh = 37)\n  nt.biomart <- biomaRt::getBM(c(\"refsnp_id\", \"allele\", \"chr_name\", \"chrom_start\",\n                        \"chrom_strand\", \"allele_1\"),\n                      filters=\"snp_filter\", values = the.snp, mart = snp.db)\n  return(nt.biomart)\n}\n\n\nflipAllele <- function(allele) {\n  flip <- \"X\"\n  if (allele == \"A\" || allele == \"a\")\n    flip <- \"T\"\n  else if (allele == \"T\" || allele == \"t\")\n    flip <- \"A\"\n  else if (allele == \"G\" || allele == \"g\")\n    flip <- \"C\"\n  else if (allele == \"C\" || allele == \"c\")\n    flip <- \"G\"\n  return(flip)\n}\n\ntestggv <- function() {\n  server = \"-t 5 popgen.uchicago.edu\"\n  p=suppressWarnings(system2(\"ping\",server,stderr=F,stdout=F))\n  if (p == 0)\n    message(\"GGV server is alive.\")\n  else {\n    message(\"GGV server is not responding.\")\n    message(paste0(\"Please contact: \", maintainer(\"RGGV\")))\n  }\n  return(p)\n}\n\nancestralState <- function(chr, pos, db) {\n  strchr <- paste0(\"chr\",as.character(chr))\n  site <- GenomicRanges::GRanges(seqnames = strchr, IRanges::IRanges(pos, pos))\n  server <- \"http://genome-data.cri.uchicago.edu/ahga/\"\n  dir <- \"human_ancestor_GR37_e59/\"\n  if (db == 'hgdp')\n    dir <- \"Ancestral_hg18/\"\n  prefix <- \"human_ancestor_\"\n  suffix <- \".fa\"\n  fafile=paste0(server, dir,prefix,as.character(chr),suffix)\n  fa <- Rsamtools::FaFile(fafile)\n  a <- Rsamtools::getSeq(fa,param=site)\n  return (as.character(a))\n}\n\n\nclusterpie <- function(geojson, server = NULL, width = NULL, height = NULL) {\n  if (is.null(server)) {\n    data <- geojson\n  }\n\n  # forward options using x\n  x = list(\n    geojsonfile = geojson,\n    data = data,\n    server = server\n  )\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'clusterpie4widget',\n    x,\n    width = width,\n    height = height,\n    package = 'RGGV'\n  )\n}\n\n# Widget output function for use in Shiny\n#\n#\nclusterpie4widgetOutput <- function(outputId, width = '100%', height = '400px'){\n  shinyWidgetOutput(outputId, 'clusterpie4widget', width, height, package = 'RGGV')\n}\n\n# Widget render function for use in Shiny\n#\n#\nrenderClusterpie4widget <- function(expr, env = parent.frame(), quoted = FALSE) {\n  if (!quoted) { expr <- substitute(expr) } # force quoted\n  shinyRenderWidget(expr, clusterpie4widgetOutput, env, quoted = TRUE)\n}\n",
    "created" : 1444938169658.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "348211431",
    "id" : "8C568A26",
    "lastKnownWriteTime" : 1445555287,
    "path" : "C:/Users/dwitonsk/Dropbox/DataViz/RGGV/R/RGGV.R",
    "project_path" : "R/RGGV.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "type" : "r_source"
}